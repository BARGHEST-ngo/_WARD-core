"""
Exploitation Crash 
"""

import re
from typing import Dict, List, Any

from ward_core.logic.models import LogData, Detection, Severity, EvidenceType, Evidence
from ward_core.heuristics.base.base_heuristic import BaseHeuristic


class ExploitationCrashHeuristic(BaseHeuristic):
    """Heuristic for detecting exploitation attempts and suspicious crashes."""
    
    # Crash pattern definitions
    NATIVE_CRASH_PATTERNS = [
        re.compile(r'signal\s+\d+\s*\([^)]+\).*?fault addr', re.IGNORECASE),
        re.compile(r'tombstone.*?pid:\s*\d+', re.IGNORECASE),
        re.compile(r'native crash.*?signal', re.IGNORECASE),
        re.compile(r'segmentation fault', re.IGNORECASE),
        re.compile(r'sigsegv.*?fault', re.IGNORECASE),
    ]
    
    JNI_CRASH_PATTERNS = [
        re.compile(r'jni.*?(critical|error|abort)', re.IGNORECASE),
        re.compile(r'native.*?method.*?crash', re.IGNORECASE),
        re.compile(r'jni.*?fatal.*?exception', re.IGNORECASE),
        re.compile(r'native.*?library.*?error', re.IGNORECASE),
    ]
    
    # Enhanced ANR patterns for spyware detection (from crash_analysis)
    ANR_PATTERNS = {
        'surveillance_blocking': [
            re.compile(r'camera.*service.*anr', re.IGNORECASE),
            re.compile(r'microphone.*capture.*blocked', re.IGNORECASE),
            re.compile(r'location.*service.*not\s+responding', re.IGNORECASE),
            re.compile(r'sensor.*manager.*anr', re.IGNORECASE)
        ],
        'data_exfiltration_blocking': [
            re.compile(r'network.*service.*blocked.*[0-9]{4,}ms', re.IGNORECASE),
            re.compile(r'upload.*service.*anr', re.IGNORECASE),
            re.compile(r'sync.*adapter.*blocked.*[0-9]{4,}ms', re.IGNORECASE)
        ],
        'evasion_anr': [
            re.compile(r'security.*service.*anr', re.IGNORECASE),
            re.compile(r'analysis.*detection.*blocked', re.IGNORECASE),
            re.compile(r'anti.*virus.*service.*anr', re.IGNORECASE)
        ],
        'general_anr': [
            re.compile(r'anr.*?in.*?([a-zA-Z0-9_.]+)', re.IGNORECASE),
            re.compile(r'application.*?not.*?responding.*?([a-zA-Z0-9_.]+)', re.IGNORECASE),
            re.compile(r'input.*?dispatching.*?timed.*?out', re.IGNORECASE),
            re.compile(r'broadcast.*intent.*stuck', re.IGNORECASE)
        ]
    }
    
    SYSTEM_CRASH_PATTERNS = [
        re.compile(r'system_server.*?crash', re.IGNORECASE),
        re.compile(r'zygote.*?(crash|died)', re.IGNORECASE),
        re.compile(r'init.*?service.*?(crash|died)', re.IGNORECASE),
        re.compile(r'kernel.*?panic', re.IGNORECASE),
        re.compile(r'watchdog.*?bark', re.IGNORECASE),
    ]
    
    # Enhanced memory corruption patterns with severity levels (from crash_analysis)
    MEMORY_CORRUPTION_PATTERNS = {
        'critical': [
            re.compile(r'heap\s+(corruption|smashing|overflow)', re.IGNORECASE),
            re.compile(r'stack\s+(smashing|buffer\s+overflow|canary)', re.IGNORECASE),
            re.compile(r'use.?after.?free', re.IGNORECASE),
            re.compile(r'double\s+free.*detected', re.IGNORECASE),
            re.compile(r'corrupted.*double.?linked\s+list', re.IGNORECASE)
        ],
        'high': [
            re.compile(r'buffer\s+overflow.*detected', re.IGNORECASE),
            re.compile(r'memory\s+corruption.*detected', re.IGNORECASE),
            re.compile(r'invalid\s+(address|pointer)', re.IGNORECASE),
            re.compile(r'wild\s+pointer.*access', re.IGNORECASE),
            re.compile(r'stack corruption detected', re.IGNORECASE)
        ],
        'medium': [
            re.compile(r'out.*?of.*?memory', re.IGNORECASE),
            re.compile(r'lowmemorykiller.*Killing.*pid=(\d+)', re.IGNORECASE),
            re.compile(r'failed.*?to.*?allocate', re.IGNORECASE),
            re.compile(r'segmentation\s+fault', re.IGNORECASE),
            re.compile(r'null\s+pointer\s+dereference', re.IGNORECASE)
        ]
    }

    # Modern Android security feature crash patterns (Android 10+)
    MODERN_SECURITY_CRASH_PATTERNS = {
        'scudo_heap_allocator': [
            re.compile(r'scudo.*heap.*corruption.*detected', re.IGNORECASE),
            re.compile(r'scudo.*invalid.*chunk.*state', re.IGNORECASE),
            re.compile(r'scudo.*double.*free.*detected', re.IGNORECASE),
            re.compile(r'scudo.*use.*after.*free', re.IGNORECASE)
        ],
        'memory_tagging_extension': [
            re.compile(r'mte.*tag.*mismatch.*detected', re.IGNORECASE),
            re.compile(r'memory.*tagging.*violation', re.IGNORECASE),
            re.compile(r'mte.*fault.*address.*tag', re.IGNORECASE),
            re.compile(r'tagged.*pointer.*access.*violation', re.IGNORECASE)
        ],
        'control_flow_integrity': [
            re.compile(r'cfi.*violation.*detected', re.IGNORECASE),
            re.compile(r'control.*flow.*integrity.*abort', re.IGNORECASE),
            re.compile(r'cfi.*indirect.*call.*check.*failed', re.IGNORECASE),
            re.compile(r'cfi.*cast.*check.*failed', re.IGNORECASE)
        ],
        'shadow_call_stack': [
            re.compile(r'shadow.*call.*stack.*corruption', re.IGNORECASE),
            re.compile(r'scs.*violation.*detected', re.IGNORECASE),
            re.compile(r'return.*address.*authentication.*failed', re.IGNORECASE)
        ],
        'hardware_assisted_security': [
            re.compile(r'pointer.*authentication.*fault', re.IGNORECASE),
            re.compile(r'pac.*violation.*detected', re.IGNORECASE),
            re.compile(r'branch.*target.*identification.*fault', re.IGNORECASE),
            re.compile(r'bti.*violation.*detected', re.IGNORECASE)
        ]
    }
    
    # Exploitation indicators based on crash patterns
    EXPLOITATION_INDICATORS = [
        re.compile(r'failed.*?to.*?unshare.*?operation.*?not.*?permitted', re.IGNORECASE),
        re.compile(r'selinux.*?denial', re.IGNORECASE),
        re.compile(r'permission.*?denied.*?for.*?sensitive', re.IGNORECASE),
        re.compile(r'access.*?violation.*?in.*?kernel', re.IGNORECASE),
        re.compile(r'privilege.*?escalation.*?attempt', re.IGNORECASE),
        re.compile(r'unauthorized.*?access.*?to.*?system', re.IGNORECASE),
    ]
    
    # Low/Suspicious crash patterns that might appear
    SUSPICIOUS_CRASH_PATTERNS = [
        re.compile(r'root.*?detection.*?failed', re.IGNORECASE),
        re.compile(r'debugger.*?detected.*?exiting', re.IGNORECASE),
        re.compile(r'tamper.*?detected.*?shutting.*?down', re.IGNORECASE),
        re.compile(r'certificate.*?pinning.*?failed', re.IGNORECASE),
        re.compile(r'security.*?check.*?failed', re.IGNORECASE),
        re.compile(r'integrity.*?verification.*?failed', re.IGNORECASE),
    ]
    
    # Signal analysis for exploitation detection
    EXPLOITATION_SIGNALS = {
        '11': 'SIGSEGV - Segmentation fault (potential buffer overflow)',
        '6': 'SIGABRT - Abort signal (heap corruption/fortify violation)',
        '4': 'SIGILL - Illegal instruction (code injection)',
        '8': 'SIGFPE - Floating point exception (integer overflow)',
        '9': 'SIGKILL - Kill signal (system termination)',
        '15': 'SIGTERM - Termination signal'
    }
    
    def __init__(self, config=None):
        super().__init__(config)

        config_dict = self._extract_config_dict(config)
        self.min_risk_score = config_dict.get('min_risk_score', 2.0)
        self.require_log_evidence = config_dict.get('require_log_evidence', True)
        self.max_detections_per_category = config_dict.get('max_detections_per_category', 5)

        # Episode clustering settings for temporal correlation
        self.episode_window_seconds = 60  # Time window for crash clustering
        self.min_crashes_for_episode = 2  # Minimum crashes to form episode
    
    @property
    def name(self) -> str:
        return "exploitation_crash"
    
    @property
    def category(self) -> str:
        return "Crash Analysis"
    
    @property
    def description(self) -> str:
        return "Analyzes crash logs for exploitation attempts and suspicious crash patterns"
    
    def analyze(self, log_data: LogData) -> List[Detection]:
        """Analyze crash patterns and exploitation attempts using realistic ADB patterns."""
        detections = []

        # Analyze different types of crashes using crash patterns
        detections.extend(self._analyze_android_runtime_crashes(log_data))
        detections.extend(self._analyze_native_crashes_realistic(log_data))
        detections.extend(self._analyze_anr_events_realistic(log_data))
        detections.extend(self._analyze_system_crashes_realistic(log_data))
        detections.extend(self._analyze_tombstone_references(log_data))
        detections.extend(self._analyze_dropbox_crashes(log_data))

        # Enhanced analysis for episode clustering
        detections.extend(self._analyze_crash_episodes_realistic(log_data))

        # Limit detections to avoid overwhelming output
        return detections[:50]

    def _analyze_android_runtime_crashes(self, log_data: LogData) -> List[Detection]:
        """Analyze realistic Android runtime crashes from parsed log data."""
        detections = []

        # Realistic Android crash patterns from actual logcat output
        android_crash_patterns = [
            re.compile(r'FATAL EXCEPTION.*Process:\s*([^\s,]+)', re.IGNORECASE),
            re.compile(r'AndroidRuntime.*FATAL EXCEPTION', re.IGNORECASE),
            re.compile(r'Process:\s*([^\s,]+).*PID:\s*(\d+)', re.IGNORECASE),
            re.compile(r'java\.lang\.RuntimeException.*Unable to start activity', re.IGNORECASE),
            re.compile(r'java\.lang\.SecurityException', re.IGNORECASE),
        ]

        # Analyze all parsed events - parsers have already filtered appropriate data
        for event in log_data.parsed_events:
            line = event.get('raw_line', '')

            for pattern in android_crash_patterns:
                match = pattern.search(line)
                if match:
                    package = self._extract_package_from_crash_line(line)

                    detection = Detection(
                        category="Android Runtime Crash",
                        package=package,
                        severity=Severity.HIGH,
                        confidence=0.9,
                        title=f"Android Runtime Crash: {package}",
                        description=f"Android runtime crash detected in {package}",
                        technical_details={
                            'crash_type': 'android_runtime',
                            'package_name': package,
                            'source_file': event.get('source_file', ''),
                            'abuse_type': 'runtime_crash'
                        },
                        evidence=[self._create_evidence(line, 0.9)]
                    )
                    detections.append(detection)

                    if len(detections) >= self.max_detections_per_category:
                        return detections

        return detections

    def _analyze_native_crashes_realistic(self, log_data: LogData) -> List[Detection]:
        """Analyze realistic native crash patterns from parsed log data."""
        detections = []

        # Realistic native crash patterns that actually appear in Android logs
        native_patterns = [
            re.compile(r'DEBUG.*signal\s+(\d+).*fault addr\s+(0x[0-9a-fA-F]+)', re.IGNORECASE),
            re.compile(r'DEBUG.*pid:\s*(\d+).*signal\s+(\d+)', re.IGNORECASE),
            re.compile(r'libc.*Fatal signal\s+(\d+)', re.IGNORECASE),
            re.compile(r'DEBUG.*backtrace:', re.IGNORECASE),
        ]

        # Analyze all parsed events - parsers have already filtered appropriate data
        for event in log_data.parsed_events:
            line = event.get('raw_line', '')

            for pattern in native_patterns:
                match = pattern.search(line)
                if match:
                    # Extract crash details
                    signal = self._extract_signal_from_line(line)
                    pid = self._extract_pid_from_line(line)
                    package = self._extract_package_from_line(line)

                    severity = self._determine_crash_severity('native_crash', signal, '')

                    detection = Detection(
                        category="Native Crash",
                        package=package,
                        severity=severity,
                        confidence=0.85,
                        title=f"Native Crash Detected (Signal {signal})",
                        description=f"Native crash with signal {signal} in process {pid}",
                        technical_details={
                            'crash_type': 'native_crash',
                            'signal': signal,
                            'signal_description': self.EXPLOITATION_SIGNALS.get(signal, 'Unknown signal'),
                            'process_id': pid,
                            'package_name': package,
                            'source_file': event.get('source_file', ''),
                            'abuse_type': 'native_crash'
                        },
                        evidence=[self._create_evidence(line, 0.85)]
                    )
                    detections.append(detection)

                    if len(detections) >= self.max_detections_per_category:
                        return detections

        return detections

    def _analyze_anr_events_realistic(self, log_data: LogData) -> List[Detection]:
        """Analyze realistic ANR events from parsed log data."""
        detections = []

        # Realistic ANR patterns from actual Android logs
        anr_patterns = [
            re.compile(r'ANR in\s+([^\s]+)', re.IGNORECASE),
            re.compile(r'ActivityManager.*ANR.*([a-zA-Z0-9_.]+)', re.IGNORECASE),
            re.compile(r'Input dispatching timed out.*([a-zA-Z0-9_.]+)', re.IGNORECASE),
            re.compile(r'Broadcast of Intent.*took.*([a-zA-Z0-9_.]+)', re.IGNORECASE),
        ]

        # Analyze all parsed events - parsers have already filtered appropriate data
        for event in log_data.parsed_events:
            line = event.get('raw_line', '')

            for pattern in anr_patterns:
                match = pattern.search(line)
                if match:
                    package = match.group(1) if match.lastindex >= 1 else self._extract_package_from_line(line)

                    detection = Detection(
                        category="Application Not Responding",
                        package=package,
                        severity=Severity.MEDIUM,
                        confidence=0.8,
                        title=f"ANR Detected: {package}",
                        description=f"Application Not Responding event detected for {package}",
                        technical_details={
                            'crash_type': 'anr',
                            'package_name': package,
                            'source_file': event.get('source_file', ''),
                            'abuse_type': 'application_not_responding'
                        },
                        evidence=[self._create_evidence(line, 0.8)]
                    )
                    detections.append(detection)

                    if len(detections) >= self.max_detections_per_category:
                        return detections

        return detections

    def _analyze_system_crashes_realistic(self, log_data: LogData) -> List[Detection]:
        """Analyze realistic system process crashes from parsed log data."""
        detections = []

        # System crash patterns from Android logs
        system_patterns = [
            re.compile(r'system_server.*died', re.IGNORECASE),
            re.compile(r'zygote.*died', re.IGNORECASE),
            re.compile(r'Watchdog.*WATCHDOG KILLING SYSTEM PROCESS', re.IGNORECASE),
            re.compile(r'kernel.*Kernel panic', re.IGNORECASE),
        ]

        # Analyze all parsed events - parsers have already filtered appropriate data
        for event in log_data.parsed_events:
            line = event.get('raw_line', '')

            for pattern in system_patterns:
                if pattern.search(line):
                    process_name = self._extract_system_process_name(line)

                    detection = Detection(
                        category="System Process Crash",
                        package="system",
                        severity=Severity.CRITICAL,
                        confidence=0.95,
                        title=f"Critical System Process Crash: {process_name}",
                        description=f"Critical system process {process_name} has crashed",
                        technical_details={
                            'crash_type': 'system_crash',
                            'process_name': process_name,
                            'source_file': event.get('source_file', ''),
                            'abuse_type': 'system_process_crash'
                        },
                        evidence=[self._create_evidence(line, 0.95)]
                    )
                    detections.append(detection)

                    if len(detections) >= self.max_detections_per_category:
                        return detections

        return detections

    def _analyze_tombstone_references(self, log_data: LogData) -> List[Detection]:
        """Analyze tombstone file references from parsed log data."""
        detections = []

        # Look for tombstone references in parsed events
        tombstone_pattern = re.compile(r'tombstone.*(/data/tombstones/tombstone_\d+)', re.IGNORECASE)

        # Analyze all parsed events - parsers have already filtered appropriate data
        for event in log_data.parsed_events:
            line = event.get('raw_line', '')

            match = tombstone_pattern.search(line)
            if match:
                tombstone_path = match.group(1)

                detection = Detection(
                    category="Native Crash Reference",
                    package="system",
                    severity=Severity.HIGH,
                    confidence=0.9,
                    title=f"Tombstone File Created: {tombstone_path}",
                    description=f"Native crash tombstone file created at {tombstone_path}",
                    technical_details={
                        'crash_type': 'tombstone_reference',
                        'tombstone_path': tombstone_path,
                        'source_file': event.get('source_file', ''),
                        'abuse_type': 'native_crash_tombstone'
                    },
                    evidence=[self._create_evidence(line, 0.9)]
                )
                detections.append(detection)

                if len(detections) >= self.max_detections_per_category:
                    return detections

        return detections

    def _analyze_dropbox_crashes(self, log_data: LogData) -> List[Detection]:
        """Analyze system crash patterns from ADB logs."""
        detections = []

        # Look for crash patterns that actually appear in ADB logs
        crash_patterns = [
            re.compile(r'Tombstone written to: /data/tombstones/tombstone_\d+', re.IGNORECASE),
            re.compile(r'Fatal signal \d+ \(SIG\w+\).*fault addr 0x[0-9a-f]+', re.IGNORECASE),
            re.compile(r'ANR in ([a-zA-Z0-9_.]+)', re.IGNORECASE),
            re.compile(r'FATAL EXCEPTION:.*RuntimeException', re.IGNORECASE),
            re.compile(r'Build fingerprint:.*tombstone', re.IGNORECASE)
        ]

        # Analyze all parsed events - parsers have already filtered appropriate data
        for event in log_data.parsed_events:
            line = event.get('raw_line', '')

            # Check each realistic crash pattern
            for i, pattern in enumerate(crash_patterns):
                match = pattern.search(line)
                if match:
                    crash_type = self._extract_realistic_crash_type(line, i)
                    package = self._extract_crash_package(line)

                    detection = Detection(
                        category="System Crash Report",
                        package=package,
                        severity=Severity.HIGH,
                        confidence=0.85,
                        title=f"System Crash Detected: {crash_type}",
                        description=f"System crash detected in ADB logs: {crash_type}",
                        technical_details={
                            'crash_type': 'system_crash',
                            'crash_subtype': crash_type,
                            'source_file': event.get('source_file', ''),
                            'abuse_type': 'system_crash_report',
                            'pattern_matched': i
                        },
                        evidence=[self._create_evidence(line, 0.85)]
                    )
                    detections.append(detection)

                if len(detections) >= self.max_detections_per_category:
                    return detections

        return detections

    def _extract_realistic_crash_type(self, line: str, pattern_index: int) -> str:
        """Extract crash type from realistic ADB log patterns."""
        crash_types = [
            'tombstone',      # Pattern 0: Tombstone written
            'fatal_signal',   # Pattern 1: Fatal signal
            'anr',           # Pattern 2: ANR
            'fatal_exception', # Pattern 3: Fatal exception
            'debug_info'     # Pattern 4: Build fingerprint with tombstone
        ]

        if pattern_index < len(crash_types):
            return crash_types[pattern_index]
        return 'unknown_crash'

    def _extract_crash_package(self, line: str) -> str:
        """Extract package name from crash line if available."""
        # Look for package patterns in crash logs
        package_patterns = [
            r'in tid \d+ \(([a-zA-Z0-9_.]+)\)',  # Fatal signal pattern
            r'ANR in ([a-zA-Z0-9_.]+)',          # ANR pattern
            r'Process: ([a-zA-Z0-9_.]+)',        # Process pattern
        ]

        for pattern in package_patterns:
            match = re.search(pattern, line)
            if match:
                return match.group(1)

        return 'system'

    def _extract_package_from_crash_line(self, line: str) -> str:
        """Extract package name from Android crash line."""
        # Look for Process: package_name pattern
        process_match = re.search(r'Process:\s*([^\s,]+)', line)
        if process_match:
            return process_match.group(1)

        return self._extract_package_from_line(line)

    def _extract_signal_from_line(self, line: str) -> str:
        """Extract signal number from crash line."""
        signal_match = re.search(r'signal\s+(\d+)', line, re.IGNORECASE)
        return signal_match.group(1) if signal_match else 'unknown'

    def _extract_pid_from_line(self, line: str) -> str:
        """Extract PID from crash line."""
        pid_match = re.search(r'pid:\s*(\d+)', line, re.IGNORECASE)
        return pid_match.group(1) if pid_match else 'unknown'

    def _extract_system_process_name(self, line: str) -> str:
        """Extract system process name from crash line."""
        process_match = re.search(r'(system_server|zygote|init|kernel)', line, re.IGNORECASE)
        return process_match.group(1) if process_match else 'system'

    def _extract_dropbox_crash_type(self, line: str) -> str:
        """Extract DropBox crash type from line."""
        if 'SYSTEM_TOMBSTONE' in line:
            return 'Native Crash'
        elif 'SYSTEM_CRASH' in line:
            return 'System Crash'
        elif 'SYSTEM_ANR' in line:
            return 'ANR'
        else:
            return 'Unknown'

    def _analyze_jni_crashes(self, log_data: LogData) -> List[Detection]:
        """Analyze JNI-related crashes."""
        detections = []
        
        for i, line in enumerate(log_data.raw_lines):
            for pattern in self.JNI_CRASH_PATTERNS:
                if pattern.search(line):
                    # Try to extract package name
                    package = self._extract_package_from_line(line)
                    
                    detection = Detection(
                        category="JNI Crash",
                        package=package,
                        severity=Severity.HIGH,
                        confidence=0.85,
                        title=f"JNI Native Library Error: {package}",
                        description=f"JNI crash detected in native library for package {package}",
                        technical_details={
                            'crash_type': 'jni_crash',
                            'package_name': package,
                            'line_number': i,
                            'abuse_type': 'jni_native_error'
                        },
                        evidence=[self._create_evidence(line, 0.85)]
                    )
                    detections.append(detection)
                    
                    if len(detections) >= self.max_detections_per_category:
                        break
            
            if len(detections) >= self.max_detections_per_category:
                break
        
        return detections
    
    def _analyze_anr_events(self, log_data: LogData) -> List[Detection]:
        """Enhanced ANR analysis with spyware pattern."""
        detections = []
        
        for i, line in enumerate(log_data.raw_lines):
            for anr_category, patterns in self.ANR_PATTERNS.items():
                for pattern in patterns:
                    match = pattern.search(line)
                    if match:
                        # Extract package name from match or line
                        package = match.group(1) if match.lastindex and match.lastindex >= 1 else self._extract_package_from_line(line)
                        
                        # Determine severity and category based on ANR type
                        severity, confidence, category = self._determine_anr_severity(anr_category, line)
                        anr_type = self._determine_anr_type(anr_category, line)
                        
                        detection = Detection(
                            category=category,
                            package=package,
                            severity=severity,
                            confidence=confidence,
                            title=f"{anr_type}: {package}",
                            description=f"{anr_type} detected for {package}",
                            technical_details={
                                'crash_type': 'anr',
                                'anr_category': anr_category,
                                'anr_type': anr_type,
                                'package_name': package,
                                'line_number': i,
                                'abuse_type': 'application_not_responding'
                            },
                            evidence=[self._create_evidence(line, confidence)]
                        )
                        detections.append(detection)
                        
                        if len(detections) >= self.max_detections_per_category:
                            break
                
                if len(detections) >= self.max_detections_per_category:
                    break
            
            if len(detections) >= self.max_detections_per_category:
                break
        
        return detections
    
    def _analyze_system_crashes(self, log_data: LogData) -> List[Detection]:
        """Analyze critical system process crashes."""
        detections = []
        
        for i, line in enumerate(log_data.raw_lines):
            for pattern in self.SYSTEM_CRASH_PATTERNS:
                if pattern.search(line):
                    # Extract system process name
                    process_match = re.search(r'(system_server|zygote|init|kernel)', line, re.IGNORECASE)
                    process_name = process_match.group(1) if process_match else 'system'
                    
                    detection = Detection(
                        category="System Crash",
                        package="system",
                        severity=Severity.CRITICAL,
                        confidence=0.95,
                        title=f"Critical System Process Crash: {process_name}",
                        description=f"Critical system process {process_name} has crashed",
                        technical_details={
                            'crash_type': 'system_crash',
                            'process_name': process_name,
                            'line_number': i,
                            'abuse_type': 'system_process_crash'
                        },
                        evidence=[self._create_evidence(line, 0.95)]
                    )
                    detections.append(detection)
                    
                    if len(detections) >= self.max_detections_per_category:
                        break
            
            if len(detections) >= self.max_detections_per_category:
                break
        
        return detections
    
    def _analyze_memory_issues(self, log_data: LogData) -> List[Detection]:
        """Enhanced memory corruption analysis with severity levels."""
        detections = []
        
        for i, line in enumerate(log_data.raw_lines):
            for severity_level, patterns in self.MEMORY_CORRUPTION_PATTERNS.items():
                for pattern in patterns:
                    if pattern.search(line):
                        # Determine specific memory issue type and severity
                        issue_type = self._determine_memory_issue_type(line)
                        package = self._extract_package_from_line(line)
                        
                        # Map severity level to Severity enum
                        severity_map = {
                            'critical': Severity.CRITICAL,
                            'high': Severity.HIGH,
                            'medium': Severity.MEDIUM
                        }
                        severity = severity_map.get(severity_level, Severity.MEDIUM)
                        
                        # Adjust confidence based on severity
                        confidence_map = {
                            'critical': 0.9,
                            'high': 0.8,
                            'medium': 0.7
                        }
                        confidence = confidence_map.get(severity_level, 0.7)
                        
                        detection = Detection(
                            category="Memory Corruption",
                            package=package,
                            severity=severity,
                            confidence=confidence,
                            title=f"{severity_level.title()} Memory Issue: {issue_type}",
                            description=f"{severity_level.title()} memory corruption detected: {issue_type} in {package}",
                            technical_details={
                                'crash_type': 'memory_corruption',
                                'issue_type': issue_type,
                                'severity_level': severity_level,
                                'package_name': package,
                                'line_number': i,
                                'abuse_type': 'memory_corruption'
                            },
                            evidence=[self._create_evidence(line, confidence)]
                        )
                        detections.append(detection)
                        
                        if len(detections) >= self.max_detections_per_category:
                            break
                
                if len(detections) >= self.max_detections_per_category:
                    break
            
            if len(detections) >= self.max_detections_per_category:
                break
        
        return detections
    
    def _analyze_exploitation_indicators(self, log_data: LogData) -> List[Detection]:
        """Analyze realistic exploitation indicators from Android logs."""
        detections = []
        
        for i, line in enumerate(log_data.raw_lines):
            for pattern in self.EXPLOITATION_INDICATORS:
                if pattern.search(line):
                    exploit_type = self._determine_exploitation_type(line)
                    package = self._extract_package_from_line(line)
                    
                    detection = Detection(
                        category="Exploitation Attempt",
                        package=package,
                        severity=Severity.CRITICAL,
                        confidence=0.9,
                        title=f"Exploitation Attempt: {exploit_type}",
                        description=f"Potential exploitation attempt detected: {exploit_type} in {package}",
                        technical_details={
                            'crash_type': 'exploitation_attempt',
                            'exploit_type': exploit_type,
                            'package_name': package,
                            'line_number': i,
                            'abuse_type': 'exploitation_attempt'
                        },
                        evidence=[self._create_evidence(line, 0.9)]
                    )
                    detections.append(detection)
                    
                    if len(detections) >= self.max_detections_per_category:
                        break
            
            if len(detections) >= self.max_detections_per_category:
                break
        
        return detections
    
    def _analyze_suspicious_crash_patterns(self, log_data: LogData) -> List[Detection]:
        """Analyze suspicious crash patterns that might indicate spyware behavior."""
        detections = []
        
        for i, line in enumerate(log_data.raw_lines):
            for pattern in self.SUSPICIOUS_CRASH_PATTERNS:
                if pattern.search(line):
                    evasion_type = self._determine_spyware_evasion_type(line)
                    package = self._extract_package_from_line(line)
                    
                    detection = Detection(
                        category="Spyware Evasion",
                        package=package,
                        severity=Severity.HIGH,
                        confidence=0.85,
                        title=f"Spyware Evasion Pattern: {evasion_type}",
                        description=f"Spyware evasion technique detected: {evasion_type} in {package}",
                        technical_details={
                            'crash_type': 'spyware_evasion',
                            'evasion_type': evasion_type,
                            'package_name': package,
                            'line_number': i,
                            'abuse_type': 'spyware_evasion'
                        },
                        evidence=[self._create_evidence(line, 0.85)]
                    )
                    detections.append(detection)
                    
                    if len(detections) >= self.max_detections_per_category:
                        break
            
            if len(detections) >= self.max_detections_per_category:
                break
        
        return detections
    
    def _determine_crash_severity(self, crash_type: str, signal: str, fault_addr: str) -> Severity:
        """Determine crash severity based on type and context."""
        if crash_type == 'system_crash':
            return Severity.CRITICAL
        
        # Check for exploitation indicators
        if signal in ['11', '6']:  # SIGSEGV, SIGABRT
            if fault_addr and fault_addr != 'unknown':
                try:
                    addr_int = int(fault_addr, 16)
                    # Check for buffer overflow patterns
                    if addr_int == 0x41414141 or addr_int == 0x42424242:
                        return Severity.CRITICAL
                    # Check for low addresses (null pointer dereference)
                    elif addr_int < 0x1000:
                        return Severity.HIGH
                except ValueError:
                    pass
        
        # Default severity based on crash type
        severity_map = {
            'native_crash': Severity.HIGH,
            'jni_crash': Severity.HIGH,
            'anr': Severity.MEDIUM,
            'memory_issue': Severity.MEDIUM,
            'exploitation_attempt': Severity.CRITICAL,
            'spyware_evasion': Severity.HIGH
        }
        
        return severity_map.get(crash_type, Severity.MEDIUM)
    
    def _determine_memory_issue_type(self, line: str) -> str:
        """Determine specific type of memory issue."""
        line_lower = line.lower()
        
        if 'heap corruption' in line_lower or 'heap smashing' in line_lower:
            return 'Heap Corruption'
        elif 'stack smashing' in line_lower or 'stack canary' in line_lower:
            return 'Stack Smashing'
        elif 'buffer overflow' in line_lower:
            return 'Buffer Overflow'
        elif 'use after free' in line_lower:
            return 'Use After Free'
        elif 'double free' in line_lower:
            return 'Double Free'
        elif 'wild pointer' in line_lower:
            return 'Wild Pointer Access'
        elif 'stack corruption' in line_lower:
            return 'Stack Corruption'
        elif 'out of memory' in line_lower:
            return 'Out of Memory'
        elif 'lowmemorykiller' in line_lower:
            return 'Low Memory Killer'
        elif 'null pointer' in line_lower:
            return 'Null Pointer Dereference'
        else:
            return 'Memory Issue'
    
    def _determine_anr_severity(self, anr_category: str, line: str) -> tuple[Severity, float, str]:
        """Determine ANR severity, confidence, and category based on type."""
        line_lower = line.lower()

        if anr_category == 'surveillance_blocking':
            # Higher severity if multiple surveillance components are blocked
            if len([word for word in ['camera', 'microphone', 'location', 'sensor'] if word in line_lower]) > 1:
                return Severity.CRITICAL, 0.95, "Multi-Component Surveillance Blocking ANR"
            return Severity.HIGH, 0.9, "Surveillance Blocking ANR"
        elif anr_category == 'data_exfiltration_blocking':
            return Severity.HIGH, 0.85, "Data Exfiltration Blocking ANR"
        elif anr_category == 'evasion_anr':
            return Severity.CRITICAL, 0.9, "Security Evasion ANR"
        else:  # general_anr
            return Severity.MEDIUM, 0.7, "Application Not Responding"
    
    def _determine_anr_type(self, anr_category: str, line: str) -> str:
        """Determine specific ANR type based on category and content."""
        line_lower = line.lower()
        
        if anr_category == 'surveillance_blocking':
            if 'camera' in line_lower:
                return 'Camera Service ANR'
            elif 'microphone' in line_lower or 'audio' in line_lower:
                return 'Audio Capture ANR'
            elif 'location' in line_lower:
                return 'Location Service ANR'
            elif 'sensor' in line_lower:
                return 'Sensor Manager ANR'
            else:
                return 'Surveillance Service ANR'
        elif anr_category == 'data_exfiltration_blocking':
            if 'network' in line_lower:
                return 'Network Service ANR'
            elif 'upload' in line_lower:
                return 'Upload Service ANR'
            elif 'sync' in line_lower:
                return 'Sync Adapter ANR'
            else:
                return 'Data Service ANR'
        elif anr_category == 'evasion_anr':
            if 'security' in line_lower:
                return 'Security Service ANR'
            elif 'analysis' in line_lower:
                return 'Analysis Detection ANR'
            elif 'antivirus' in line_lower:
                return 'Antivirus Service ANR'
            else:
                return 'Security Evasion ANR'
        else:  # general_anr
            return 'Application Not Responding'
    
    def _determine_exploitation_type(self, line: str) -> str:
        """Determine specific type of exploitation indicator."""
        line_lower = line.lower()
        
        if 'unshare' in line_lower and 'operation not permitted' in line_lower:
            return 'Sandbox Escape Attempt'
        elif 'selinux denial' in line_lower:
            return 'SELinux Policy Violation'
        elif 'permission denied' in line_lower and 'sensitive' in line_lower:
            return 'Unauthorized Access Attempt'
        elif 'access violation' in line_lower and 'kernel' in line_lower:
            return 'Kernel Access Violation'
        elif 'privilege escalation' in line_lower:
            return 'Privilege Escalation'
        elif 'unauthorized access' in line_lower:
            return 'Unauthorized System Access'
        else:
            return 'Security Violation'
    
    def _determine_spyware_evasion_type(self, line: str) -> str:
        """Determine specific type of suspicious crash pattern."""
        line_lower = line.lower()
        
        if 'root detection failed' in line_lower:
            return 'Root Detection Failure'
        elif 'debugger detected' in line_lower:
            return 'Anti-Debug Detection'
        elif 'tamper detected' in line_lower:
            return 'Tamper Detection'
        elif 'certificate pinning failed' in line_lower:
            return 'Certificate Pinning Failure'
        elif 'security check failed' in line_lower:
            return 'Security Check Failure'
        elif 'integrity verification failed' in line_lower:
            return 'Integrity Verification Failure'
        else:
            return 'Suspicious Security Pattern'
    
    def _extract_package_from_line(self, line: str) -> str:
        """Extract package name from log line."""
        # Try various package name patterns
        patterns = [
            r'([a-zA-Z0-9_.]+\.[a-zA-Z0-9_.]+\.[a-zA-Z0-9_.]+)',  # Full package name
            r'package[:\s]+([a-zA-Z0-9_.]+)',                      # "package: com.example"
            r'pid[:\s]+\d+[,\s]+([a-zA-Z0-9_.]+)',                # "pid: 1234, com.example"
        ]
        
        for pattern in patterns:
            match = re.search(pattern, line)
            if match:
                package = match.group(1)
                # Validate it looks like a package name
                if '.' in package and len(package) > 5:
                    return package
        
        return 'unknown'
    
    def _create_evidence(self, content: str, confidence: float = 0.8) -> Evidence:
        """Create evidence object for crash detection."""
        return Evidence(
            type=EvidenceType.LOG_ANCHOR,
            content=content.strip(),
            confidence=confidence
        )
    
    def _analyze_modern_security_crashes(self, log_data: LogData) -> List[Detection]:
        """Analyze modern Android security feature crashes (Android 10+)."""
        detections = []

        for i, line in enumerate(log_data.raw_lines):
            for security_feature, patterns in self.MODERN_SECURITY_CRASH_PATTERNS.items():
                for pattern in patterns:
                    match = pattern.search(line)
                    if match:
                        # Extract package information if available
                        package = self._extract_package_from_line(line)

                        # Determine severity based on security feature
                        severity = self._determine_modern_security_severity(security_feature, line)
                        confidence = 0.9  # High confidence for modern security features

                        # Create detection
                        detection = Detection(
                            category="Crash Analysis",
                            subcategory="Modern Security Feature",
                            package=package,
                            severity=severity,
                            confidence=confidence,
                            title=f"Modern Security Crash: {security_feature.replace('_', ' ').title()}",
                            description=f"Modern Android security feature detected exploitation attempt: {security_feature}",
                            technical_details={
                                'security_feature': security_feature,
                                'crash_pattern': pattern.pattern,
                                'line_number': i + 1,
                                'android_version': 'Android 10+',
                                'exploitation_indicator': True
                            },
                            evidence=[
                                Evidence(
                                    type=EvidenceType.LOG_ANCHOR,
                                    content=line.strip(),
                                    confidence=0.95,
                                    line_number=i + 1
                                )
                            ]
                        )
                        detections.append(detection)
                        break  # Only one detection per line

        return detections

    def _determine_modern_security_severity(self, security_feature: str, line: str) -> Severity:
        """Determine severity for modern security feature crashes."""
        # Modern security features detecting violations are high severity
        critical_features = {'control_flow_integrity', 'memory_tagging_extension', 'shadow_call_stack'}
        high_features = {'scudo_heap_allocator', 'hardware_assisted_security'}

        # Escalate severity if multiple violations are detected in the same line
        line_lower = line.lower()
        violation_keywords = ['violation', 'corruption', 'fault', 'abort', 'failed']
        violation_count = sum(1 for keyword in violation_keywords if keyword in line_lower)

        base_severity = Severity.CRITICAL if security_feature in critical_features else \
                       Severity.HIGH if security_feature in high_features else Severity.MEDIUM

        # Escalate if multiple violations detected
        if violation_count > 1 and base_severity != Severity.CRITICAL:
            return Severity.CRITICAL if base_severity == Severity.HIGH else Severity.HIGH

        return base_severity

    def _extract_config_dict(self, config) -> Dict[str, Any]:
        """Extract configuration dictionary from various config formats."""
        if config and hasattr(config, 'settings'):
            return config.settings
        elif config and hasattr(config, '__dict__'):
            return config.__dict__
        else:
            return config or {}

    def _analyze_crash_episodes_realistic(self, log_data: LogData) -> List[Detection]:
        """Analyze crash episodes using realistic ADB log patterns."""
        detections = []

        # Look for clustered crashes within time windows
        crash_events = []

        # Parse realistic crash patterns from actual Android logs
        for i, line in enumerate(log_data.raw_lines):
            # Look for fatal signals (actual logcat format)
            fatal_signal_match = re.search(r'Fatal signal (\d+) \(([^)]+)\).*pid (\d+) \(([^)]+)\)', line)
            if fatal_signal_match:
                signal_num, signal_name, pid, process_name = fatal_signal_match.groups()
                crash_events.append({
                    'line_number': i,
                    'signal': signal_num,
                    'signal_name': signal_name,
                    'pid': pid,
                    'process_name': process_name,
                    'line': line.strip(),
                    'timestamp': self._extract_timestamp_from_line(line)
                })

        # Group crashes by time windows (realistic episode detection)
        if len(crash_events) >= self.min_crashes_for_episode:
            episodes = self._group_crashes_by_time_window(crash_events)

            for episode in episodes:
                if len(episode) >= self.min_crashes_for_episode:
                    # Determine if this looks like exploitation
                    exploitation_indicators = self._assess_exploitation_likelihood(episode)

                    if exploitation_indicators['score'] >= 0.7:
                        detection = Detection(
                            category="Crash Episode",
                            package=episode[0]['process_name'],
                            severity=Severity.HIGH if exploitation_indicators['score'] >= 0.8 else Severity.MEDIUM,
                            confidence=exploitation_indicators['score'],
                            title=f"Clustered Crashes: {len(episode)} crashes in {episode[0]['process_name']}",
                            description=f"Detected {len(episode)} crashes within {self.episode_window_seconds}s window",
                            technical_details={
                                'crash_count': len(episode),
                                'time_window_seconds': self.episode_window_seconds,
                                'signals': [e['signal'] for e in episode],
                                'exploitation_indicators': exploitation_indicators['indicators'],
                                'threat_type': 'crash_episode'
                            },
                            evidence=[Evidence(
                                type=EvidenceType.LOG_ANCHOR,
                                content=episode[0]['line'],
                                confidence=exploitation_indicators['score']
                            )]
                        )
                        detections.append(detection)

        return detections

    def _extract_timestamp_from_line(self, line: str) -> str:
        """Extract timestamp from Android log line."""
        # Look for common Android log timestamp formats
        timestamp_match = re.search(r'(\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3})', line)
        if timestamp_match:
            return timestamp_match.group(1)
        return "unknown"

    def _group_crashes_by_time_window(self, crash_events: List[Dict]) -> List[List[Dict]]:
        """Group crashes by time windows for episode detection."""
        episodes = []
        current_episode = []

        for crash in crash_events:
            if not current_episode:
                current_episode = [crash]
            else:
                # Simple grouping by line proximity (realistic for ADB logs)
                line_diff = crash['line_number'] - current_episode[-1]['line_number']
                if line_diff <= 100:  # Within 100 lines (rough time window)
                    current_episode.append(crash)
                else:
                    if len(current_episode) >= self.min_crashes_for_episode:
                        episodes.append(current_episode)
                    current_episode = [crash]

        # Add final episode
        if len(current_episode) >= self.min_crashes_for_episode:
            episodes.append(current_episode)

        return episodes

    def _assess_exploitation_likelihood(self, episode: List[Dict]) -> Dict:
        """Assess likelihood of exploitation based on realistic indicators."""
        score = 0.5  # Base score
        indicators = []

        # Check for exploitation-indicating signals
        signals = [int(e['signal']) for e in episode]
        if 11 in signals:  # SIGSEGV
            score += 0.2
            indicators.append("SIGSEGV_present")
        if 6 in signals:   # SIGABRT
            score += 0.1
            indicators.append("SIGABRT_present")

        # Check for system processes (higher concern)
        processes = [e['process_name'] for e in episode]
        system_processes = ['system_server', 'zygote', 'surfaceflinger', 'mediaserver']
        if any(proc in system_processes for proc in processes):
            score += 0.2
            indicators.append("system_process_crash")

        # Multiple different processes crashing (system instability)
        if len(set(processes)) > 1:
            score += 0.1
            indicators.append("multiple_process_crash")

        # Rapid succession (within small line range)
        line_range = episode[-1]['line_number'] - episode[0]['line_number']
        if line_range <= 50:  # Very close together
            score += 0.1
            indicators.append("rapid_succession")

        return {
            'score': min(score, 1.0),
            'indicators': indicators
        }
